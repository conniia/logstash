input{
  tcp {
    port => 514
    type => syslog
  }
  udp {
    port => 514
    type => syslog
  }
}
filter{
  if [message] =~ "alert" or [message] =~ "emergency" {
  grok{
    patterns_dir => "/usr/logdata/patterner"
    match => { "message" => "%{MYLOGALERT}" }
    remove_field => ["@version","host"]
     }
   }
if [message] =~ "critical" {
  grok{
    patterns_dir => "/usr/logdata/patterner"
    match => { "message" => "%{MYLOGCRIT}" }
    remove_field => ["@version","host"]
     }
   }
  if [message] =~ "information" {
  grok{
    patterns_dir => "/usr/logdata/patterner"
    match => { "message" => "%{MYLOGINFO}" }
    remove_field => ["@version","host"]
     }
   }
  if [message] =~ "notification" {
   if [message] =~ "service=tcp" or [message] =~ "service=udp" {
   grok{
   patterns_dir => ["/usr/logdata/patterner"]
   match => { "message" => "%{MYLOGNOTIFTU}" }
   remove_field => ["@version","host"]
     }
   }
   else {
   grok {
   patterns_dir => ["/usr/logdata/patterner"]
   match => { "message" => "%{MYLOGNOTIF}" }
   remove_field => ["@version","host"]
      }
    }  
  }
  if [message] =~ "warn" {
  grok {
    patterns_dir => "/usr/logdata/patterner"
    match => { "message" => "%{MYLOGWARN}" }
    remove_field => ["@version","host"]
    }
  }
   mutate {
           convert => { "sport" => "integer" }
           convert => { "dport" => "integer" }
           convert => { "sent_byte" => "integer" }
           convert => { "rcvd_byte" => "integer" }
           convert => { "occurtimes" => "integer" }
           convert => { "policy_id" => "integer" }
          }
  }
output{
  if "_grokparsefailure" in [tags]{
     file {
     path => "/usr/logdata/fail.txt"
        }
}
  elasticsearch{
       hosts => ["172.17.5.142:9200"]
       index => "junipor_syslog-%{+YYYY-MM-dd}"
       document_type => "netflow_v9"
      }
  stdout{
    codec => rubydebug
   }
 }
